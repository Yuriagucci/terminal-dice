<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="
    default-src 'self';
    style-src 'self' 'unsafe-inline';
    script-src 'self' 'unsafe-inline';
    font-src 'self';
    object-src 'none';
    base-uri 'self';
    form-action 'none';
  ">
  
  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png">
  
  <title>Terminal Dice Roller</title>
  
  <style>
    :root {
      --terminal-bg: #1e1e1e;
      --terminal-text: #d4d4d4;
      --prompt-color: #569cd6;
      --input-color: #ce9178;
      --output-color: #b5cea8;
      --error-color: #f44747;
      --crit-hit-color: #4ec9b0; /* Bright Teal */
      --crit-fail-color: #d16969; /* Muted Red */
      --accent-color: #c586c0; /* Purple accent for rolls */
      --dimmed-roll-color: #777; /* Dim color for discarded adv/dis roll */
    }
    
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: 'Consolas', 'Courier New', Courier, monospace;
      background-color: var(--terminal-bg);
      color: var(--terminal-text);
      font-size: 16px;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 15px;
      box-sizing: border-box;
    }
    
    #terminal-container {
      width: 100%;
      max-width: 800px; /* Max width for readability */
      height: 80vh; /* Height constraint */
      max-height: 700px; /* Max height */
      background-color: var(--terminal-bg);
      border: 1px solid #333;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      overflow: hidden; /* Contain children */
      position: relative;
    }
    
    #output-area {
      flex-grow: 1; /* Takes up available space */
      overflow-y: auto; /* Enable scrolling */
      padding: 15px;
      line-height: 1.4;
    }
    
    #output-area > div { /* Style each line */
      margin-bottom: 5px;
      white-space: pre-wrap; /* Wrap text like a terminal */
      word-wrap: break-word;
      opacity: 0;
      animation: fadeIn 0.5s forwards;
    }
    
    .command-echo {
      color: var(--prompt-color);
    }
    .command-echo::before {
      content: "> ";
    }
    
    .result-line {
      color: var(--output-color);
    }
    .error-line {
      color: var(--error-color);
    }
    
    /* Specific styling within results */
    .result-line code, .error-line code { /* Dice notation */
      color: var(--input-color);
      background-color: rgba(255, 255, 255, 0.05);
      padding: 1px 4px;
      border-radius: 3px;
      font-weight: bold;
    }
    .result-line .rolls { /* Individual rolls / Adv/Dis rolls */
      color: var(--accent-color);
    }
    .result-line .rolls .discarded { /* Dim discarded adv/dis roll */
      color: var(--dimmed-roll-color);
      text-decoration: line-through;
    }
    .result-line .total { /* Final total */
      font-weight: bold;
      color: white;
    }
    
    /* Crit/Fail Styling */
    .crit-hit, .crit-fail {
      font-weight: bold;
      display: inline-block; /* Allows padding */
      padding: 0 5px;
      border-radius: 3px;
      margin-left: 5px; /* Space from roll */
    }
    .crit-hit {
      color: black;
      background-color: var(--crit-hit-color);
    }
    .crit-fail {
      color: black;
      background-color: var(--crit-fail-color);
    }
    
    #input-line {
      display: flex;
      align-items: center;
      padding: 5px 15px 10px 15px;
      border-top: 1px solid #333;
    }
    
    #input-prompt {
      color: var(--prompt-color);
      margin-right: 8px;
      font-weight: bold;
    }
    
    #dice-input {
      flex-grow: 1;
      background-color: transparent;
      border: none;
      outline: none;
      color: var(--input-color);
      font-family: inherit;
      font-size: inherit;
      caret-color: var(--terminal-text); /* Blinking cursor color */
    }
    
    /* Custom scrollbar for terminal look */
    #output-area::-webkit-scrollbar { width: 8px; }
    #output-area::-webkit-scrollbar-track { background: #2a2a2a; border-radius: 4px; }
    #output-area::-webkit-scrollbar-thumb { background-color: #555; border-radius: 4px; border: 2px solid #2a2a2a; }
    #output-area::-webkit-scrollbar-thumb:hover { background-color: #777; }
    
    /* Animation for new output lines */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    /* Sound effect button (invisible) */
    #sound-btn {
      display: none;
    }
  </style>
</head>
<body>

  <div id="terminal-container">
    <div id="output-area">
      <div>Welcome to the Terminal Dice Roller!</div>
      <div>Supports: <code>xDy+m*f</code>, <code>adY+m</code>, <code>ddY+m</code>, <code>n#xDy+m</code></div>
      <div>Type 'clear' to clear screen. Press Enter to roll.</div>
      <div>--------------------------------------------------</div>
    </div>
    <div id="input-line">
      <span id="input-prompt">&gt;</span>
      <input type="text" id="dice-input" autofocus autocomplete="off">
    </div>
  </div>

  <!-- Audio element for roll sound -->
  <audio id="roll-sound" src="roll.mp3" preload="auto"></audio>
  
  <script>
    const diceInput = document.getElementById('dice-input');
    const outputArea = document.getElementById('output-area');
    const rollSound = document.getElementById('roll-sound');

    function rollDie(sides) {
      if (sides < 1) return 1; // Treat invalid dice sides as 1
      return Math.floor(Math.random() * sides) + 1;
    }

    function addOutputLine(htmlContent, type = 'result') {
      const line = document.createElement('div');
      line.classList.add(`${type}-line`);
      line.innerHTML = htmlContent; // Use innerHTML to render spans correctly
      outputArea.appendChild(line);
      // Scroll to bottom smoothly (optional, modern browsers)
      outputArea.scrollTo({ top: outputArea.scrollHeight, behavior: 'smooth' });
      // Fallback for older browsers
      // outputArea.scrollTop = outputArea.scrollHeight;
    }

    function showError(message) {
      addOutputLine(message, 'error');
    }

    function playRollSound() {
       // Basic error check in case the element doesn't exist or fails to load
      if (rollSound && typeof rollSound.play === 'function') {
        rollSound.currentTime = 0;
        rollSound.play().catch(error => {
          // Ignore errors often caused by user interaction policies
          // console.log("Roll sound play prevented:", error);
        });
      }
    }

    function processInput() {
      const inputText = diceInput.value.trim();
      const inputUpper = inputText.toUpperCase(); // Use uppercase for matching

      if (inputText) {
        // Sanitize input slightly before echoing to prevent basic HTML injection if tags weren't intended
        const sanitizedInput = inputText.replace(/</g, "&lt;").replace(/>/g, "&gt;");
        addOutputLine(sanitizedInput, 'command-echo');
      } else {
        // Don't process empty input
        diceInput.value = ''; // Clear just in case
        return;
      }

      if (inputText.toLowerCase() === 'clear') {
        outputArea.innerHTML = `<div>Screen cleared.</div><div>--------------------------------------------------</div>`;
        diceInput.value = '';
        return;
      }

      // --- Regex Definitions ---
      // Updated to include optional factor (* or /) for # rolls
      const individualRollRegex = /^\s*(\d+)#(\d*)D(\d+)\s*([+\-]\s*\d+)?\s*([*\/]\s*\d+)?\s*$/;
      // Standard roll regex remains the same
      const standardRollRegex = /^\s*(?:(\d*)?(AD|DD)D?(\d+)|(\d*)D(\d+))\s*([+\-]\s*\d+)?\s*([*\/]\s*\d+)?\s*$/;

      let match;

      // --- Try Matching Individual Rolls (n#...) ---
      // THIS SECTION HAS BEEN MODIFIED
      if ((match = inputUpper.match(individualRollRegex))) {
        const numRolls = parseInt(match[1], 10);
        const numDice = match[2] ? parseInt(match[2], 10) : 1;
        const diceSides = parseInt(match[3], 10);
        const modifierString = match[4] ? match[4].replace(/\s/g, '') : null;
        const factorString = match[5] ? match[5].replace(/\s/g, '') : null; // New: Capture factor

        const modifierValue = modifierString ? parseInt(modifierString, 10) : 0;
        let factorValue = 1, factorOperator = ''; // New: Parse factor

        if (factorString) {
          factorOperator = factorString.charAt(0);
          factorValue = parseInt(factorString.substring(1), 10);
        }

        // --- Validation ---
        if (isNaN(numRolls) || isNaN(numDice) || isNaN(diceSides) || diceSides < 1 || numDice < 1 || numRolls < 1) {
          showError(`Invalid numbers in individual roll notation: <code>${inputText}</code>`);
          diceInput.value = '';
          return;
        }
         if (isNaN(modifierValue)) {
             showError(`Invalid modifier number: <code>${inputText}</code>`);
             diceInput.value = '';
             return;
         }
        if (factorString && isNaN(factorValue)) { // New: Validate factor value
          showError(`Invalid factor number: <code>${inputText}</code>`);
          diceInput.value = '';
          return;
        }
        if (factorOperator === '/' && factorValue === 0) { // New: Validate division by zero
          showError("Division by zero is not allowed.");
          diceInput.value = '';
          return;
        }
        // --- End Validation ---


        let notationString = `${numDice}d${diceSides}${modifierString || ''}${factorString || ''}`; // New: Include factor in notation display
        addOutputLine(`Rolling ${numRolls} sets of <code>${notationString}</code>...`);
        playRollSound(); // Play sound once for the batch
        let resultsListHTML = '';

        for (let i = 0; i < numRolls; i++) {
          let currentRollSum = 0;
          const rolls = [];
          let critStatus = '';

          for (let j = 0; j < numDice; j++) {
            const roll = rollDie(diceSides);
            rolls.push(roll);
            currentRollSum += roll;
            // Crit status applies if rolling a single d20 within the set
            if (numDice === 1 && diceSides === 20) {
              if (roll === 20) critStatus = '<span class="crit-hit">Critical Hit!</span>';
              if (roll === 1) critStatus = '<span class="crit-fail">Critical Fail!</span>';
            }
          }

          const resultAfterModifier = currentRollSum + modifierValue;
          let finalValue = resultAfterModifier; // Initialize final value

          // New: Apply the factor to each set's result
          if (factorOperator === '*') {
            finalValue = resultAfterModifier * factorValue;
          } else if (factorOperator === '/') {
            finalValue = Math.floor(resultAfterModifier / factorValue); // Use floor division
          }

          // Construct the output string for this set, showing steps
          let setOutput = `Set ${i + 1}: <span class="rolls">[${rolls.join(', ')}]</span>`;
          if (numDice === 1 && critStatus) {
              setOutput += ` ${critStatus}`; // Show crit right after single roll
          }
          if (numDice > 1) {
              setOutput += ` = ${currentRollSum}`; // Show sum if multiple dice per set
          }
          if (modifierString) {
              setOutput += ` ${modifierString.startsWith('-') ? '-' : '+'} ${Math.abs(modifierValue)} = ${resultAfterModifier}`; // Show modifier step
          }
          // Handle edge case: crit on d20+0*2 - need intermediate step shown
          else if (numDice === 1 && critStatus && factorString) {
               setOutput += ` (= ${resultAfterModifier})`;
          }

          if (factorString) {
              setOutput += ` ${factorOperator} ${factorValue} = <span class="total">${finalValue}</span>`; // Show factor step and final total
          } else {
              // If no factor, the result after modifier is the final total.
              // Show '= total' only if there were intermediate steps (sum, modifier, crit)
              if (modifierString || numDice > 1 || critStatus) {
                   setOutput += ` = <span class="total">${finalValue}</span>`;
              } else if (numDice === 1) {
                 // Simple 1dY roll per set, no modifier/factor/crit
                 setOutput += ` => <span class="total">${finalValue}</span>`; // Just show the result as total
              }
          }

          resultsListHTML += setOutput + '<br>'; // Add line break for HTML output
        }
        addOutputLine(resultsListHTML.trimEnd()); // Add the combined results

      // --- Try Matching Standard Rolls (including advantage/disadvantage) ---
      // THIS SECTION REMAINS LARGELY THE SAME
      } else if ((match = inputUpper.match(standardRollRegex))) {
        let numDice, diceSides, advDisMarker;
        if (match[2]) { // Adv/Dis match
          numDice = match[1] ? parseInt(match[1], 10) : 1; // Should always be 1 here ideally
          advDisMarker = match[2];
          diceSides = parseInt(match[3], 10);
          if (numDice > 1) { // Technically redundant due to regex structure, but safe check
             showError(`Advantage/Disadvantage (ad/dd) must use a single die (e.g., ad20, dd20+5). Input: <code>${inputText}</code>`);
             diceInput.value = '';
             return;
           }
        } else { // Standard D match
          numDice = match[4] ? parseInt(match[4], 10) : 1;
          diceSides = parseInt(match[5], 10);
        }
        const modifierString = match[6] ? match[6].replace(/\s/g, '') : null;
        const factorString = match[7] ? match[7].replace(/\s/g, '') : null;

        const modifierValue = modifierString ? parseInt(modifierString, 10) : 0;
        let factorValue = 1, factorOperator = '';
        if (factorString) {
          factorOperator = factorString.charAt(0);
          factorValue = parseInt(factorString.substring(1), 10);
        }

        // --- Validation ---
        if (isNaN(numDice) || isNaN(diceSides) || diceSides < 1 || numDice < 1) {
          showError(`Invalid numbers in roll notation: <code>${inputText}</code>`);
          diceInput.value = '';
          return;
        }
         if (isNaN(modifierValue)) {
            showError(`Invalid modifier number: <code>${inputText}</code>`);
            diceInput.value = '';
            return;
         }
        if (factorString && isNaN(factorValue)) {
          showError(`Invalid factor number: <code>${inputText}</code>`);
          diceInput.value = '';
          return;
        }
        if (factorOperator === '/' && factorValue === 0) {
          showError("Division by zero is not allowed.");
          diceInput.value = '';
          return;
        }
        // --- End Validation ---

        let totalSum = 0;
        const rolls = [];
        let critStatus = '';
        let displayRolls = '', resultTextStart = '';

        playRollSound(); // Play sound once per command

        if (advDisMarker) { // Advantage/Disadvantage roll
          const roll1 = rollDie(diceSides);
          const roll2 = rollDie(diceSides);
          let chosenRoll, rollType = '';
          let discardedRoll;

          if (advDisMarker === 'AD') {
            chosenRoll = Math.max(roll1, roll2);
            discardedRoll = Math.min(roll1, roll2);
            rollType = 'Adv';
          } else { // DD case
            chosenRoll = Math.min(roll1, roll2);
            discardedRoll = Math.max(roll1, roll2);
            rollType = 'Dis';
          }
          // Style the rolls to show which was chosen/discarded
          let r1_style = (roll1 === chosenRoll) ? `<strong>${roll1}</strong>` : `<span class="discarded">${roll1}</span>`;
          let r2_style = (roll2 === chosenRoll) ? `<strong>${roll2}</strong>` : `<span class="discarded">${roll2}</span>`;
          // Ensure consistent order for display (e.g., lower first)
          displayRolls = `<span class="rolls">[${Math.min(roll1, roll2) === roll1 ? r1_style : r2_style}, ${Math.max(roll1, roll2) === roll1 ? r1_style : r2_style}]</span> -> ${chosenRoll}`;

          totalSum = chosenRoll;
          if (diceSides === 20) {
            if (chosenRoll === 20) critStatus = '<span class="crit-hit">Critical Hit!</span>';
            if (chosenRoll === 1) critStatus = '<span class="crit-fail">Critical Fail!</span>';
          }
          resultTextStart = `Roll (${rollType}): ${displayRolls} ${critStatus}`;

        } else { // Standard roll without AD/DD
          for (let i = 0; i < numDice; i++) {
            const roll = rollDie(diceSides);
            rolls.push(roll);
            totalSum += roll;
            // Crit status only relevant for single d20 rolls
            if (numDice === 1 && diceSides === 20) {
              if (roll === 20) critStatus = '<span class="crit-hit">Critical Hit!</span>';
              if (roll === 1) critStatus = '<span class="crit-fail">Critical Fail!</span>';
            }
          }
          displayRolls = `<span class="rolls">[${rolls.join(', ')}]</span>`;
          resultTextStart = `Rolls: ${displayRolls} ${critStatus}`;
           // Show intermediate sum only if multiple dice were rolled
          if (numDice > 1) {
             resultTextStart += ` = ${totalSum}`;
          }
        }

        let resultAfterModifier = totalSum + modifierValue;
        let finalResult = resultAfterModifier; // Initialize final result

        // Apply factor AFTER modifier
        if (factorOperator === '*') {
          finalResult = resultAfterModifier * factorValue;
        } else if (factorOperator === '/') {
          finalResult = Math.floor(resultAfterModifier / factorValue); // Use floor division
        }

        // Construct the full result text, showing steps
        let resultText = resultTextStart;
        if (modifierString) {
          // Append modifier step only if it wasn't implicitly part of the start (like single die roll)
          if (numDice > 1 || advDisMarker || (numDice === 1 && !critStatus)){ // Show step if sum shown, or adv/dis, or simple 1dY
             resultText += ` ${modifierString.startsWith('-') ? '-' : '+'} ${Math.abs(modifierValue)} = ${resultAfterModifier}`;
          } else if (numDice === 1 && critStatus) { // Handle crit d20+mod
             resultText += ` ${modifierString.startsWith('-') ? '-' : '+'} ${Math.abs(modifierValue)} = ${resultAfterModifier}`;
          } else { // Single die roll without crit, resultAfterModifier is the base for factor
             // Don't show intermediate step if only modifier applied, unless factor follows
              if (!factorString) { // If no factor, this is the end result
                  resultText = `Result: <span class="rolls">[${totalSum}]</span> ${modifierString.startsWith('-') ? '-' : '+'} ${Math.abs(modifierValue)} = <span class="total">${finalResult}</span>`;
              } else { // Factor follows, show step
                  resultText += ` ${modifierString.startsWith('-') ? '-' : '+'} ${Math.abs(modifierValue)} = ${resultAfterModifier}`;
              }
          }
        }
        if (factorString) {
          resultText += ` ${factorOperator} ${factorValue} = <span class="total">${finalResult}</span>`; // Append factor step and final total
        } else if (modifierString) {
           // If only modifier was applied, and intermediate step was shown, add final total span
           // This case is mostly handled above or factorString exists. Add span if it wasn't added yet.
           if (!resultText.includes('<span class="total">')) {
               resultText += ` = <span class="total">${finalResult}</span>`;
           }
        } else {
          // No modifier, no factor. Show total only if intermediate steps shown (adv/dis, multi-dice, crit)
          if (advDisMarker || numDice > 1 || critStatus) {
            resultText += ` = <span class="total">${finalResult}</span>`;
          } else if (numDice === 1) {
             // Simple 1dY result, no steps needed, resultTextStart already shows roll
             resultText = `Result: ${displayRolls} => <span class="total">${finalResult}</span>`;
          }
        }

        addOutputLine(resultText);
      } else {
        // If neither regex matches
        showError(`Invalid command or dice notation: <code>${inputText}</code>`);
      }

      diceInput.value = ''; // Clear input field after processing
      diceInput.focus(); // Keep focus on input
    }

    // --- Event Listeners ---
    diceInput.addEventListener('keydown', function(event) {
      if (event.key === 'Enter') {
        event.preventDefault(); // Prevent default form submission (if applicable)
        processInput();
      }
      // Add Up Arrow for history (Optional - requires storing history)
      // if (event.key === 'ArrowUp') { /* Retrieve last command */ }
    });

    // Refocus input if user clicks in the terminal area
    outputArea.addEventListener('click', () => diceInput.focus());
    document.getElementById('input-line').addEventListener('click', () => diceInput.focus());

    // Initial focus on input when page loads
    diceInput.focus();

  </script>
</body>
</html>
