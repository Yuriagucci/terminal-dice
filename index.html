<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <link rel="icon" type="image/png" href="icon.ico">
  
  <title>Dice Terminal</title>
  
  <link rel="stylesheet" href="main.css">

</head>
<body>
  <div id="splash-screen">
    <div class="terminal-icon">_&lt;</div>
    <div class="splash-title">Dice Terminal</div>
    <div class="splash-subtitle">Loading...</div>
  </div>

  <div id="terminal-container">
    <button id="clipboard-btn" title="Copy roll log to clipboard">ðŸ“‹ Copy Log</button>
    <div id="output-area">
      <div>Welcome to the Dice Terminal!</div>
      <div>Supports: <code>xDy+m*f</code>, <code>adY+m</code>, <code>ddY+m</code>, <code>n#xDy+m</code></div>
      <div>Type 'clear' to clear screen. Press Enter to roll.</div>
      <div>Type 'legend' to see list of possible commands.</div>
      <div>--------------------------------------------------</div>
    </div>
    <div id="input-line">
      <span id="input-prompt">&gt;</span>
      <input type="text" id="dice-input" placeholder="Enter" autofocus autocomplete="off">
    </div>
  </div>


  <script> //inputs
    const diceInput = document.getElementById('dice-input');
    const outputArea = document.getElementById('output-area');
    const rollSound = document.getElementById('roll-sound');

    function addOutputLine(htmlContent, type = 'result') {
      const line = document.createElement('div');
      line.classList.add(`${type}-line`);
      line.innerHTML = htmlContent;
      outputArea.appendChild(line);
      outputArea.scrollTo({ top: outputArea.scrollHeight, behavior: 'smooth' });
    }

    function showError(message) {
      addOutputLine(message, 'error');
    }
  </script>
  <script> //diceUtils
    function rollDie(sides) {
    if (sides < 1) return 1; // Treat invalid dice sides as 1
    return Math.floor(Math.random() * sides) + 1;
    }


    function playRollSound() {
    if (rollSound && typeof rollSound.play === 'function') {
        rollSound.currentTime = 0;
        rollSound.play().catch(error => {});
    }
    }

    function parseDiceExpression(expr) {
    // First check for # notation
    const multipleRollsMatch = expr.match(/^(\d+)#(.+)$/i);
    if (multipleRollsMatch) {
        const numRolls = parseInt(multipleRollsMatch[1]);
        const innerExpr = multipleRollsMatch[2];
        return { type: 'multiple', count: numRolls, expr: innerExpr };
    }

    // Check for advantage/disadvantage with modifiers
    const advDisMatch = expr.match(/^(ad|dd)(\d+)(.*)$/i);
    if (advDisMatch) {
        const type = advDisMatch[1].toLowerCase();
        const sides = parseInt(advDisMatch[2]);
        const modifiers = advDisMatch[3].trim();
        return { 
        type: 'advdis', 
        adv: type === 'ad', 
        sides,
        modifiers: modifiers ? parseDiceExpression(modifiers) : null
        };
    }

    // Split the expression into tokens, handling both d and D, percentage dice, and percentage calculations
    const tokens = expr.match(/(\d+%\d+|\d*[dD][%]|\d*[dD]\d+|[+\-*/]|\d+)/g) || [];
    const parsed = [];

    for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];
        
        // Handle percentage calculation (x%y)
        if (token.includes('%') && !token.includes('d') && !token.includes('D')) {
        const [percent, value] = token.split('%');
        parsed.push({ type: 'percent', percent: parseInt(percent), value: parseInt(value) });
        }
        // Handle dice notation (both d and D and percentage)
        else if (token.match(/[dD]/)) {
        if (token.includes('%')) {
            const num = token.split(/[dD]/)[0];
            const count = num ? parseInt(num) : 1;
            parsed.push({ type: 'dice', count, sides: 100 });
        } else {
            const [num, sides] = token.split(/[dD]/);
            const count = num ? parseInt(num) : 1;
            parsed.push({ type: 'dice', count, sides: parseInt(sides) });
        }
        }
        // Handle operators
        else if (['+', '-', '*', '/'].includes(token)) {
        parsed.push({ type: 'operator', value: token });
        }
        // Handle numbers
        else if (!isNaN(token)) {
        parsed.push({ type: 'number', value: parseInt(token) });
        }
    }

    return parsed;
    }

    function evaluateDiceExpression(parsed) {
    // Handle multiple rolls
    if (parsed.type === 'multiple') {
        let results = [];
        for (let i = 0; i < parsed.count; i++) {
        const innerParsed = parseDiceExpression(parsed.expr);
        const { result, output } = evaluateDiceExpression(innerParsed);
        results.push({ result, output });
        }
        return { 
        result: results.map(r => r.result), 
        output: results.map((r, i) => `Set ${i + 1}: ${r.output} = <span class="total">${r.result}</span>`).join('<br>')
        };
    }

    // Handle advantage/disadvantage
    if (parsed.type === 'advdis') {
        const roll1 = rollDie(parsed.sides);
        const roll2 = rollDie(parsed.sides);
        const chosen = parsed.adv ? Math.max(roll1, roll2) : Math.min(roll1, roll2);
        const discarded = parsed.adv ? Math.min(roll1, roll2) : Math.max(roll1, roll2);
        
        let critStatus = '';
        if (parsed.sides === 20) {
        if (chosen === 20) critStatus = '<span class="crit-hit">Critical Hit!</span>';
        if (chosen === 1) critStatus = '<span class="crit-fail">Critical Fail!</span>';
        }

        const rollText = `<span class="rolls">[${roll1 === chosen ? 
        `<strong>${roll1}</strong>` : `<span class="discarded">${roll1}</span>`}, ${
        roll2 === chosen ? 
        `<strong>${roll2}</strong>` : `<span class="discarded">${roll2}</span>`}]</span> -> ${chosen}`;

        let result = chosen;
        let output = `Roll (${parsed.adv ? 'Adv' : 'Dis'}): ${rollText} ${critStatus}`;

        // Handle modifiers if present
        if (parsed.modifiers) {
        let currentResult = result;
        let currentOutput = output;
        
        // Process each modifier operation in sequence
        for (let i = 0; i < parsed.modifiers.length; i++) {
            if (parsed.modifiers[i].type === 'operator') {
            const operator = parsed.modifiers[i].value;
            const nextToken = parsed.modifiers[i + 1];
            
            if (nextToken) {
                let modValue;
                if (nextToken.type === 'number') {
                modValue = nextToken.value;
                } else if (nextToken.type === 'dice') {
                const { result: diceResult } = evaluateDiceExpression([nextToken]);
                modValue = diceResult;
                } else if (nextToken.type === 'percent') {
                const { result: percentResult } = evaluateDiceExpression([nextToken]);
                modValue = percentResult;
                }
                
                if (operator === '+') currentResult += modValue;
                else if (operator === '-') currentResult -= modValue;
                else if (operator === '*') currentResult *= modValue;
                else if (operator === '/') currentResult = Math.floor(currentResult / modValue);
                
                currentOutput += ` ${operator} ${modValue} = ${currentResult}`;
            }
            }
        }
        
        result = currentResult;
        output = currentOutput;
        }

        return { result, output };
    }

    // Handle regular expressions
    let result = 0;
    let currentOperator = '+';
    let output = '';

    for (let i = 0; i < parsed.length; i++) {
        const token = parsed[i];
        
        if (token.type === 'dice') {
        const rolls = [];
        let sum = 0;
        let critStatus = '';
        
        for (let j = 0; j < token.count; j++) {
            const roll = rollDie(token.sides);
            rolls.push(roll);
            sum += roll;
            // Only check for critical hits/fails on d20
            if (token.sides === 20) {
            if (roll === 20) critStatus = '<span class="crit-hit">Critical Hit!</span>';
            if (roll === 1) critStatus = '<span class="crit-fail">Critical Fail!</span>';
            }
        }
        
        const rollText = `<span class="rolls">[${rolls.join(', ')}]</span>`;
        output += `${rollText} = ${sum} ${critStatus}`;
        
        if (currentOperator === '+') result += sum;
        else if (currentOperator === '-') result -= sum;
        else if (currentOperator === '*') result *= sum;
        else if (currentOperator === '/') result = Math.floor(result / sum);
        
        if (i < parsed.length - 1 && parsed[i + 1].type === 'operator') {
            output += ` ${parsed[i + 1].value} `;
        }
        }
        else if (token.type === 'percent') {
        const percentValue = Math.floor((token.percent / 100) * token.value);
        output += `${token.percent}% of ${token.value} = ${percentValue}`;
        
        if (currentOperator === '+') result += percentValue;
        else if (currentOperator === '-') result -= percentValue;
        else if (currentOperator === '*') result *= percentValue;
        else if (currentOperator === '/') result = Math.floor(result / percentValue);
        
        if (i < parsed.length - 1 && parsed[i + 1].type === 'operator') {
            output += ` ${parsed[i + 1].value} `;
        }
        }
        else if (token.type === 'number') {
        output += token.value;
        
        if (currentOperator === '+') result += token.value;
        else if (currentOperator === '-') result -= token.value;
        else if (currentOperator === '*') result *= token.value;
        else if (currentOperator === '/') result = Math.floor(result / token.value);
        
        if (i < parsed.length - 1 && parsed[i + 1].type === 'operator') {
            output += ` ${parsed[i + 1].value} `;
        }
        }
        else if (token.type === 'operator') {
        currentOperator = token.value;
        }
    }

    return { result, output };
    }


  </script>
  <script> //UI and splash somethings..
           // --- Event Listeners ---
    let lastInput = "";

    diceInput.addEventListener('keydown', function(event) {
      if (event.key === 'Enter') {
        event.preventDefault();
        const currentInput = diceInput.value.trim();
        if (currentInput) {
          lastInput = currentInput;
          processInput();
        } else {
          processInput();
        }
      } else if (event.key === 'Tab') {
        event.preventDefault();
        diceInput.value = lastInput;
      }
    });


    outputArea.addEventListener('click', () => diceInput.focus());
    document.getElementById('input-line').addEventListener('click', () => diceInput.focus());
    diceInput.focus();

    // Add clipboard functionality
    const clipboardBtn = document.getElementById('clipboard-btn');

    clipboardBtn.addEventListener('click', function() {
    const outputText = outputArea.innerText;
    navigator.clipboard.writeText(outputText).then(() => {
        // Show feedback
        const originalText = clipboardBtn.textContent;
        clipboardBtn.textContent = 'âœ“ Copied!';
        clipboardBtn.classList.add('copied');
        
        // Reset button after 2 seconds
        setTimeout(() => {
        clipboardBtn.textContent = originalText;
        clipboardBtn.classList.remove('copied');
        }, 2000);
    }).catch(err => {
        console.error('Failed to copy text: ', err);
    });
    });


    // Splash screen functionality
    const splashScreen = document.getElementById('splash-screen');
    
    // Hide splash screen after 2 seconds
    setTimeout(() => {
      splashScreen.classList.add('hidden');
      // Remove splash screen from DOM after fade out
      setTimeout(() => {
        splashScreen.remove();
      }, 1000);
    }, 2000);
  </script>
  <script> //ManyThings
    
    function drawCard() {
      const deck = [
        { name: "Balance", effect: "Your alignment changes. Lawful becomes chaotic, good becomes evil, and vice versa." },
        { name: "Comet", effect: "Defeat the next hostile monster alone to gain a level, or this card has no effect." },
        { name: "Donjon", effect: "You are imprisoned in an extradimensional sphere. You draw no more cards.", endDraws: true },
        { name: "Euryale", effect: "You are cursed with a -2 penalty on saving throws until ended by a god or The Fates card." },
        { name: "The Fates", effect: "You can erase one event as if it never happened." },
        { name: "Flames", effect: "A powerful devil becomes your enemy until one of you dies." },
        { name: "Fool", effect: "Lose 10,000 XP and draw again, counting both draws as one." },
        { name: "Gem", effect: "25 pieces of jewelry worth 2,000 gp each or 50 gems worth 1,000 gp each appear at your feet." },
        { name: "Idiot", effect: "Permanently reduce Intelligence by 1d4+1. You can draw one additional card." },
        { name: "Jester", effect: "Gain 10,000 XP or draw two additional cards." },
        { name: "Key", effect: "A rare or rarer magic weapon appears in your hands." },
        { name: "Knight", effect: "A 4th-level fighter of your race appears and serves you loyally until death." },
        { name: "Moon", effect: "You can cast the Wish spell 1d3 times." },
        { name: "Rogue", effect: "An NPC becomes hostile toward you. Only a Wish spell or divine intervention can end this hostility." },
        { name: "Ruin", effect: "All wealth you own, other than magic items, is lost." },
        { name: "Skull", effect: "You summon an avatar of death that fights you alone until one of you dies." },
        { name: "Star", effect: "Increase one ability score by 2, up to a maximum of 24." },
        { name: "Sun", effect: "Gain 50,000 XP and a wondrous item." },
        { name: "Talons", effect: "All magic items you wear or carry disintegrate." },
        { name: "Throne", effect: "Gain proficiency in Persuasion and rightful ownership of a keep, currently occupied by monsters." },
        { name: "Vizier", effect: "Within a year, you can ask a question and receive a truthful answer." },
        { name: "The Void", effect: "Your soul is trapped in an object. You draw no more cards.", endDraws: true }
      ];

      const card = deck[Math.floor(Math.random() * deck.length)];
      addOutputLine(`Card drawn: <strong>${card.name}</strong> - ${card.effect}`);

      if (card.name === "Donjon" || card.name === "The Void") {
        canDraw = false;
        drawCount = 0;
        manyThingsMode = false;
        addOutputLine("Many Things mode deactivated due to the card effect.");
      } else if (card.endDraws) {
        canDraw = false;
        drawCount = 0;
        addOutputLine("You can no longer draw cards.");
      } else if (card.name === "Fool") {
        drawCount--;
        addOutputLine("You must draw again, counting both draws as one.");
      } else if (card.name === "Idiot") {
        drawCount++;
        addOutputLine("You can draw one additional card.");
      } else if (card.name === "Jester") {
        drawCount += 2;
        addOutputLine("You can draw two additional cards.");
      } else {
        drawCount--;
        addOutputLine(`Draws remaining: ${drawCount}`);
      }

      if (drawCount <= 0 && canDraw) {
        addOutputLine("You have completed your draws.");
        manyThingsMode = false;
      }
    }
  </script>
  <script>//Spells
        const spellDamage = {
      fireball: "8d6",
      magicMissile: "3d4+3",
      scorchingRay: "2d6",
      chromaticOrb: "3d8",
      lightningBolt: "8d6",
      inflictWounds: "3d10",
      disintegrate: "10d6+40",
      blight: "8d8",
      coneOfCold: "8d8",
      burningHands: "3d6",
      thunderwave: "2d8",
      boomingBlade: "1d8",
      greenFlameBlade: "1d8",
      mindSliver: "1d6",
      dissonantWhispers: "3d6",
      eldritchBlast: "1d10",
      guidingBolt: "4d6",
      iceKnife: "1d10+2d6",
      spiritGuardians: "3d8",
      moonbeam: "2d10",
      sacredFlame: "1d8",
    };

    function processSpellInput(inputText) {
      const spellMatch = inputText.match(/(\w+)(?:\s+(\d+)(?:th|st|nd|rd))?(.*)/i);
      if (!spellMatch) return null;

      const spellName = spellMatch[1].toLowerCase();
      const spellLevel = parseInt(spellMatch[2]) || null;
      const modifiers = spellMatch[3]?.trim() || "";

      if (!spellDamage[spellName]) return null;

      if (spellLevel && spellLevel > 9) {
        showError("Spell level cannot exceed 9th level.");
        return null;
      }

      let baseDamage = spellDamage[spellName];

      // Adjust damage for upcasting
      if (spellLevel) {
        const baseLevel = {
          fireball: 3,
          magicMissile: 1,
          scorchingRay: 2,
          chromaticOrb: 1,
          lightningBolt: 3,
          inflictWounds: 1,
          disintegrate: 6,
          blight: 4,
          coneOfCold: 5,
          burningHands: 1,
          thunderwave: 1,
          boomingBlade: 0,
          greenFlameBlade: 0,
          mindSliver: 0,
          dissonantWhispers: 1,
          eldritchBlast: 0,
          guidingBolt: 1,
          iceKnife: 1,
          spiritGuardians: 3,
          moonbeam: 2,
          sacredFlame: 0,
        }[spellName] || 0;

        const extraDice = {
          fireball: "d6",
          lightningBolt: "d6",
          scorchingRay: "d6",
          inflictWounds: "d10",
          blight: "d8",
          coneOfCold: "d8",
          burningHands: "d6",
          thunderwave: "d8",
          guidingBolt: "d6",
          moonbeam: "d10",
          spiritGuardians: "d8",
        }[spellName];

        if (extraDice && spellLevel > baseLevel) {
          const extraLevels = spellLevel - baseLevel;
          baseDamage += `+${extraLevels}${extraDice}`;
        }
      }

      // Handle combining spells and modifiers with operators (e.g., fireball + fireball + fireball or 1 + 2 + 2 + + 3 / 2 * 2)
      const combinedSpells = modifiers.split(/([+\-*/])/).map(mod => mod.trim().toLowerCase());
      let combinedDamage = baseDamage;

      combinedSpells.forEach((mod, index) => {
        if (spellDamage[mod]) {
          combinedSpells[index] = `(${spellDamage[mod]})`;
        }
      });

      const expression = [baseDamage, ...combinedSpells].join(' ');

      return expression.trim();
    }

  </script>
  <script>

    let manyThingsMode = false;
    let drawCount = 0;
    let canDraw = true;

    function processInput() {
      const inputText = diceInput.value.trim();

      if (inputText) {
        addOutputLine(inputText, 'command-echo');
      } else {
        diceInput.value = '';
        return;
      }

      const spellResult = processSpellInput(inputText);
      if (spellResult) {
        const parsed = parseDiceExpression(spellResult);
        const { result, output } = evaluateDiceExpression(parsed);
        addOutputLine(`${output} = <span class="total">${result}</span>`);
        diceInput.value = '';
        return;
      }

      if (inputText.toLowerCase() === 'manythings') {
        if (manyThingsMode) {
          manyThingsMode = false;
          addOutputLine("Many Things mode deactivated.");
        } else {
          manyThingsMode = true;
          drawCount = 0;
          canDraw = true;
          addOutputLine("Many Things mode activated. Type 'declare X', X being the amount you want to draw then type 'draw' to draw a card.");
        }
        diceInput.value = '';
        return;
      }

      if (manyThingsMode) {
        if (inputText.toLowerCase().startsWith('declare')) {
          const parts = inputText.split(' ');
          if (parts.length === 2 && !isNaN(parts[1])) {
            drawCount = parseInt(parts[1]);
            addOutputLine(`Draw count declared: ${drawCount}`);
          } else {
            showError("Invalid declaration. Use 'declare <number>' to set your draw count.");
          }
        } else if (inputText.toLowerCase() === 'draw') {
          if (!canDraw) {
            showError("You can no longer draw cards.");
          } else if (drawCount <= 0) {
            showError("Declare your draw count before drawing cards.");
          } else {
            drawCard();
          }
        } else {
          showError("Invalid command in Many Things mode. Use 'declare <number>' or 'draw'.");
        }
        diceInput.value = '';
        return;
      }

      if (inputText.toLowerCase() === 'clear') {
        outputArea.innerHTML = `<div>Screen cleared.</div><div>--------------------------------------------------</div>`;
        diceInput.value = '';
        return;
      }

      if (inputText.toLowerCase() === 'legend') {
        const legendText = `
        <div>--------------------------------------------------</div>
        <div><strong>Dice Roll Commands:</strong></div>
        <div>--------------------------------------------------</div>
        <div><code>xDy</code> - Roll x dice with y sides (e.g., 3d6)</div>
        <div><code>d%</code> or <code>d100</code> - Roll a percentage die (1-100)</div>
        <div><code>x%y</code> - Calculate x percent of y (e.g., 50%20 = 10)</div>
        <div><code>xDy + m</code> - Roll x dice with y sides and add m (e.g., 2d20 + 5)</div>
        <div><code>xDy * f</code> - Roll x dice with y sides and multiply by f (e.g., 1d6 * 2)</div>
        <div><code>xDy / f</code> - Roll x dice with y sides and divide by f (e.g., 1d20 / 2)</div>
        <div><code>n#xDy</code> - Roll n sets of x dice with y sides (e.g., 5#2d6)</div>
        <div><code>adY</code> - Roll with advantage (e.g., ad20)</div>
        <div><code>ddY</code> - Roll with disadvantage (e.g., dd20)</div>
        <div><code>adY + m</code> - Roll with advantage and add m (e.g., ad20 + 5)</div>
        <div><code>ddY * f</code> - Roll with disadvantage and multiply by f (e.g., dd20 * 2)</div>
        <div>--------------------------------------------------</div>
        <div><strong>Examples:</strong></div>
        <div>--------------------------------------------------</div>
        <div><code>3d6 + 2</code> - Roll 3 six-sided dice and add 2</div>
        <div><code>d%</code> - Roll a percentage die (1-100)</div>
        <div><code>2d% + 10</code> - Roll 2 percentage dice and add 10</div>
        <div><code>50%20</code> - Calculate 50% of 20 (result: 10)</div>
        <div><code>100%20 + 2</code> - Calculate 100% of 20 and add 2 (result: 22)</div>
        <div><code>1d20 + 5 * 2</code> - Roll 1d20, add 5, then multiply by 2</div>
        <div><code>5#2d6 + 3</code> - Roll 5 sets of 2d6+3</div>
        <div><code>ad20 + 5</code> - Roll d20 with advantage and add 5</div>
        <div><code>dd20 * 2</code> - Roll d20 with disadvantage and multiply by 2</div>
        <div>--------------------------------------------------</div>
        <div>Type 'clear' to clear the screen</div>
        <div>--------------------------------------------------</div>
        `;
        addOutputLine(legendText);
        diceInput.value = '';
        return;
      }

      try {
        const parsed = parseDiceExpression(inputText);
        if (parsed.length === 0 && !parsed.type) {
          throw new Error('Invalid dice expression');
        }
        
        playRollSound();
        const { result, output } = evaluateDiceExpression(parsed);
        
        if (Array.isArray(result)) {
          // Handle multiple roll results
          addOutputLine(output);
        } else {
          addOutputLine(`${output} = <span class="total">${result}</span>`);
        }
      } catch (error) {
        showError(`Invalid dice expression: <code>${inputText}</code>`);
      }

      diceInput.value = '';
      diceInput.focus();
    }

  </script>



  <footer style="position: fixed; bottom: 0; left: 0; padding: 5px; font-size: 12px; width: 100%; text-align: left;">
    &copy; 2025 Dice Terminal | Yuriagucci
  </footer>
</body>
</html>

